type Kernel @entity {
    id: ID! # kernel does not have proxy address, so it just needs the single address
    appID: String!
    permissions: [KernelPermission!] @derivedFrom(field: "id")
}

type ACL @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [ACLPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
}

type EVMScriptRegistry @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [EVMScriptRegistryPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    executors: [Bytes!]

}

type Vault @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [VaultPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    transfers: [VaultTransferList!] @derivedFrom(field: "id")
    deposits: [VaultDepositList!] @derivedFrom(field: "id")

}

type VaultTransferList @entity {
    id: ID! # counter
    tokenAddress: [Bytes!]
    to: [Bytes!]
    amount: [BigInt!]

}

type VaultDepositList @entity {
    id: ID! # counter
    tokenAddress: [Bytes!]
    sender: [Bytes!]
    amount: [BigInt!]

}

type TokenManager @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [TokenManagerPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
}

type Finance @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [FinancePermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    periods: [FinancePeriod!] @derivedFrom(field: "appAddress")
    transactions: [FinanceTransaction!] @derivedFrom(field: "appAddress")


}

type FinancePeriod @entity {
    id: ID! # period ID
    appAddress: Bytes # Finance app addr
    starts: BigInt!
    ends: BigInt!
}

type FinanceTransaction @entity {
    id: ID! # transaction ID
    appAddress: Bytes # Finance app addr
    incoming: Boolean
    entity: Bytes!
    amount: BigInt!
    reference: String
}

type Voting @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [VotingPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    supportRequiredPercent: BigInt
    minQuorumPercent: BigInt
    votes: [Vote!] @derivedFrom(field: "appAddress")
}

type Vote @entity {
    id: ID! # vote ID
    appAddress: Bytes!
    creator: Bytes!
    metadata: String!
    supporters: [Bytes!]
    supportersStake: [BigInt!]
    nonSupporters: [Bytes!]
    nonSupportersStake: [BigInt!]
    executed: Boolean # i.e. the vote passed

}

# Need to use baseapps, because the proxy addr isn't created
# at the start, so we need to grab baseAddress from appID relationship
type BaseApp @entity {
    id: ID! # appID
    baseAddress: Bytes
}


# Here I include all roles in one entity. It acts like an object holding all roles
# We will only query the ones we need, when we need them, so that it can look clean across all apps
# contains roles and managers
type FinancePermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canChangeBudget: [String!]
    canChangePeriod: [String!]
    canCreatePayments: [String!]
    canManagePayments: [String!]
    canExecutePayments: [String!]
    managesChangeBudget: Bytes
    managesChangePeriod: Bytes
    managesCreatePayments: Bytes
    managesManagePayments: Bytes
    managesExecutePayments: Bytes
}

type TokenManagerPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canAssign: [String!]
    canBurn: [String!]
    canIssue: [String!]
    canMint: [String!]
    canRevokeVestings: [String!]
    managesAssign: Bytes
    managesBurn: Bytes
    managesIssue: Bytes
    managesMint: Bytes
    managesRevokeVestings: Bytes
}

type VotingPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canCreateVotes: [String!]
    canModifyQuorum: [String!]
    canModifySupport: [String!]
    managesCreateVotes: Bytes
    managesModifyQuorum: Bytes
    managesModifySupport: Bytes
}

type EVMScriptRegistryPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canAddExecutor: [String!]
    canEnableAndDisableExecutors: [String!]
    managesAddExecutor: Bytes
    managesEnableAndDisableExecutors: Bytes
}

type ACLPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canCreatePermissions: [String!]
    managesCreatePermissions: Bytes
}

type KernelPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canManageApps: [String!]
    managesManageApps: Bytes
}

type VaultPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canTransfer: [String!]
    managesTransfers: Bytes
}