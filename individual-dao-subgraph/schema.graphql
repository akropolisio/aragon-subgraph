# The kernel is unique, it is not an app. It houses all the other apps. not sure how this works yet
type Kernel @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [KernelPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed

}

type ACL @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [ACLPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type EVMScriptRegisty @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [EVMScriptRegistryPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type Vault @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [VaultPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type TokenManager @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [TokenManagerPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type Finance @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [FinancePermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type Voting @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissions: [VotingPermission!] @derivedFrom(field: "id")
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

# Need to use baseapps, because the proxy addr isn't created
# at the start, so we need to grab baseAddress from appID relationship
type BaseApp @entity {
    id: ID! # appID
    baseAddress: Bytes
}


# Here I include all roles in one entity. It acts like an object holding all roles
# We will only query the ones we need, when we need them, so that it can look clean across all apps
# contains roles and managers
type FinancePermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canChangeBudget: [Bytes!]
    canChangePeriod: [Bytes!]
    canCreatePayments: [Bytes!]
    canManagePayments: [Bytes!]
    canExecutePayments: [Bytes!]
    managesChangeBudget: Bytes
    managesChangePeriod: Bytes
    managesCreatePayments: Bytes
    managesManagePayments: Bytes
    managesExecutePayments: Bytes
}

type TokenManagerPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canAssign: [Bytes!]
    canBurn: [Bytes!]
    canIssue: [Bytes!]
    canMint: [Bytes!]
    canRevokeVestings: [Bytes!]
    managesAssign: Bytes
    managesBurn: Bytes
    managesIssue: Bytes
    managesMint: Bytes
    managesRevokeVestings: Bytes
}

type VotingPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canCreateVotes: [Bytes!]
    canModifyQuorum: [Bytes!]
    canModifySupport: [Bytes!]
    managesCreateVotes: Bytes
    managesModifyQuorum: Bytes
    managesModifySupport: Bytes
}

type EVMScriptRegistryPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canAddExecutor: [Bytes!]
    canEnableAndDisableExecutors: [Bytes!]
    managesAddExecutor: Bytes
    managesEnableAndDisableExecutors: Bytes
}

type ACLPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canCreatePermissions: [Bytes!]
    managesCreatePermissions: Bytes
}

type KernelPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canManageApps: [Bytes!]
    managesManageApps: Bytes
}

type VaultPermission @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    canTransfer: [Bytes!]
    managesTransfers: Bytes
}


## every app should have a proxy app
## gets filled when NewAppProxy() event is emitted
## ProxyApp entity implies we are in the KERNEL_APP_ADDR_NAMESPACE
#type ProxyApp @entity {
#    id: ID! # is the proxy address. this is because the proxy address never changes. the base app address can change
#    appName: String!
#    appID: Bytes!
#    upgradeable: Boolean
#    # params: [Bytes!] # maybe needed
#}
#
## gets filled when namespace is 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb - KERNEL_APP_ADDR_NAMESPACE from event SetApp()
## KERNEL_APP_ADDR_NAMESPACE is only for references to default apps, which are vault, acl, and evm script registry so far. note here the proxy address gets set, and not the base address.
## This never ever update
#type DefaultApp @entity {
#    id: ID! #id is app id
#    appName: String!
#    proxyAddress: Bytes! # note here we set the proxy Address of the default app, rather than the base address. NOT an array, since proxy address doesnt change
#}
#
## Upon launch through aragon dapp, all similar contracts (i.e. all voting contracts) will point to the same BaseApp, and we get this info from the first event SetApp() emitted
## gets filled when namespace is 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f - KERNEL_APP_BASES_NAMESPACE
#type BaseApp @entity {
#    id: ID! # we make the ID the appID, because the address could change for VOTING app, but the hash of VOTING app will always be the same. note this wouldn't work on a global dao
#    appName: String # I include both appID and Name for clarity, but they are really the same information in different form
#    baseAddress: Bytes! # could be an array, to keep history of all base apps
#    # TODO: need to relate this entity to app entity
#}

## We get this from the ACL contract
#type AppPermission @entity {
#    id: ID! # must be the app Address
#    appName: String
#    permissionOwner: [AppRole!] @derivedFrom(field: "id") # this will look like "MINT_ROLE: 0xasf32534nnjkrejk324jl234"
#    permissionManagers: [AppRole!] @derivedFrom(field: "id") # this could be an array to keep history of all permission managers
#}
