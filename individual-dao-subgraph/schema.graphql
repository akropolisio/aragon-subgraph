# The kernel is unique, it is not an app. It houses all the other apps. not sure how this works yet
type Kernel @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed

}

type ACL @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type EVMScriptRegisty @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type Vault @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type TokenManager @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type Finance @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

type Voting @entity {
    id: ID! # app proxy address
    baseAddress: Bytes
    appID: Bytes
    upgradeable: Boolean
    permissionOnwer: [AppRole!]
    permissionManager: [AppRole!]
    defaultApp: Boolean
    # params: [Bytes!] maybe needed
}

# Need to use baseapps, because the proxy addr isn't created
# at the start, so we need to grab baseAddress from appID relationship
type BaseApp @entity {
    id: ID! # appID
    baseAddress: Bytes
}


# Here I include all roles in one entity. It acts like an object holding all roles
# We will only query the ones we need, when we need them, so that it can look clean across all apps
type AppRole @entity {
    id: ID! # must end up being the app address: String so there will be 7 of these
    FINANCE_CHANGE_BUDGETS_ROLE_HASH: String
    FINANCE_CHANGE_PERIOD_ROLE_HASH_HASH: String
    FINANCE_CREATE_PAYMENTS_ROLE_HASH: String
    FINANCE_MANAGE_PAYMENTS_ROLE_HASH: String
    FINANCE_EXECUTE_PAYMENTS_ROLE_HASH: String
    TOKEN_MANAGER_ASSIGN_ROLE_HASH: String
    TOKEN_MANAGER_BURN_ROLE_HASH: String
    TOKEN_MANAGER_ISSUE_ROLE_HASH: String
    TOKEN_MANAGER_MINT_ROLE_HASH: String
    TOKEN_MANAGER_REVOKE_VESTINGS_ROLE_HASH: String
    VOTING_CREATE_VOTES_ROLE_HASH: String
    VOTING_MODIFY_QUORUM_ROLE_HASH: String
    VOTING_MODIFY_SUPPORT_ROLE_HASH: String
    EVM_SCRIPT_REGISTY_REGISTRY_ADD_EXECUTOR_ROLE_HASH: String
    EVM_SCRIPT_REGISTY_REGISTRY_MANAGER_ROLE_HASH: String
    VAULT_TRANSFER_ROLE_HASH: String
    ACL_CREATE_PERMISSIONS_ROLE_HASH: String
    KERNEL_APP_MANAGER_ROLE_HASH: String
    APP_DEFAULT_VOTING_APP_ID: String
    APP_DEFAULT_TOKENMANGER_APP_ID: String
    APP_DEFAULT_FINANCE_APP_ID: String
    KERNEL_DEFAULT_VAULT_APP_ID: String
    KERNEL_DEFAULT_ACL_APP_ID: String
    KERNEL_DEFAULT_EVM_SCRIPT_REGISTRY_ID: String
}


## every app should have a proxy app
## gets filled when NewAppProxy() event is emitted
## ProxyApp entity implies we are in the KERNEL_APP_ADDR_NAMESPACE
#type ProxyApp @entity {
#    id: ID! # is the proxy address. this is because the proxy address never changes. the base app address can change
#    appName: String!
#    appID: Bytes!
#    upgradeable: Boolean
#    # params: [Bytes!] # maybe needed
#}
#
## gets filled when namespace is 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb - KERNEL_APP_ADDR_NAMESPACE from event SetApp()
## KERNEL_APP_ADDR_NAMESPACE is only for references to default apps, which are vault, acl, and evm script registry so far. note here the proxy address gets set, and not the base address.
## This never ever update
#type DefaultApp @entity {
#    id: ID! #id is app id
#    appName: String!
#    proxyAddress: Bytes! # note here we set the proxy Address of the default app, rather than the base address. NOT an array, since proxy address doesnt change
#}
#
## Upon launch through aragon dapp, all similar contracts (i.e. all voting contracts) will point to the same BaseApp, and we get this info from the first event SetApp() emitted
## gets filled when namespace is 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f - KERNEL_APP_BASES_NAMESPACE
#type BaseApp @entity {
#    id: ID! # we make the ID the appID, because the address could change for VOTING app, but the hash of VOTING app will always be the same. note this wouldn't work on a global dao
#    appName: String # I include both appID and Name for clarity, but they are really the same information in different form
#    baseAddress: Bytes! # could be an array, to keep history of all base apps
#    # TODO: need to relate this entity to app entity
#}

## We get this from the ACL contract
#type AppPermission @entity {
#    id: ID! # must be the app Address
#    appName: String
#    permissionOwner: [AppRole!] @derivedFrom(field: "id") # this will look like "MINT_ROLE: 0xasf32534nnjkrejk324jl234"
#    permissionManagers: [AppRole!] @derivedFrom(field: "id") # this could be an array to keep history of all permission managers
#}
